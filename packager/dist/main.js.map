{"mappings":";;;;;;;;AEGO,MAAM;IACT,cAAyB,KAAK;IAE9B,aAAc;QACV,CAAA,GAAA,kBAAM,EAAE,EAAE,CAAC,qBAAqB,CAAC;YAC7B,IAAI,CAAC,WAAW,EAAE,QAAQ;QAC9B;QAEA,CAAA,GAAA,kBAAM,EAAE,EAAE,CAAC,cAAc;YACrB,IAAI,CAAC,WAAW,EAAE;QACtB;IACJ;IAEA,QAAW,IAAa,EAAc;QAClC,IAAI,IAAI,CAAC,WAAW,EAChB,IAAI,CAAC,WAAW,CAAC,QAAQ;QAG7B,IAAI,CAAC,WAAW,GAAG;QAEnB,OAAO,KAAK,QAAQ;IACxB;AAyCJ;;;;;;AE9DO,MAAe;;IACV,SAAkB;IAE1B,YAAY,AAAU,OAAe,CAAE;aAAjB,UAAA;IACtB;IAEO,QAAQ,KAAY,EAAE;QACzB,QAAQ,GAAG,CAAC,CAAA,GAAA,YAAI,EAAE,SAAS,CAAC,IAAI,CAAC,OAAO;QACxC,QAAQ,GAAG,CAAC,CAAA,GAAA,YAAI,EAAE,GAAG,CAAC,MAAM,KAAK;QAEjC,CAAA,GAAA,kBAAM,EAAE,IAAI,CAAC;IACjB;IAEO,SAAS;QACZ,IAAI,IAAI,CAAC,QAAQ,EAAE;QAEnB,QAAQ,GAAG,CAAC,CAAA,GAAA,YAAI,EAAE,YAAY,CAAC,IAAI,CAAC,OAAO;QAC3C,QAAQ,GAAG,CAAC,CAAA,GAAA,YAAI,EAAE,MAAM,CAAC;IAC7B;IAEO,WAAW;QACd,IAAI,IAAI,CAAC,QAAQ,EAAE;QAEnB,QAAQ,GAAG,CAAC,CAAA,GAAA,YAAI,EAAE,YAAY,CAAC,IAAI,CAAC,OAAO;QAC3C,QAAQ,GAAG,CAAC,CAAA,GAAA,YAAI,EAAE,MAAM,CAAC;IAC7B;IAEQ,UAAU;QACd,QAAQ,GAAG,CAAC,CAAA,GAAA,YAAI,EAAE,WAAW,CAAC,IAAI,CAAC,OAAO;QAE1C,IAAI,CAAC,QAAQ,GAAG;IACpB;IAEQ,OAAO,OAAe,EAAE;QAC5B,QAAQ,GAAG,CAAC,CAAA,GAAA,YAAI,EAAE,SAAS,CAAC,IAAI,CAAC,OAAO;QACxC,QAAQ,GAAG,CAAC,CAAA,GAAA,YAAI,EAAE,GAAG,CAAC;QAEtB,CAAA,GAAA,kBAAM,EAAE,IAAI,CAAC;IACjB;IAEO,WAAuB;QAC1B,OAAO,IAAI,QAAQ,CAAA;YACf,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,CAAC;gBACjB,IAAI,CAAC,OAAO;gBAEZ,QAAQ;YACZ,GAAG,KAAK,CAAC,CAAC;gBACN,IAAI,CAAC,MAAM,CAAC;YAChB;QACJ;IACJ;AAGJ;;;;;ADrDA,MAAM,YAAE,8BAAQ,EAAE,GAAG,CAAA,GAAA,eAAO;AAErB,MAAM,kDAAmB,CAAA,GAAA,yCAAG;;;IAC/B,YAAY,AAAQ,SAAiB,EAAE,AAAQ,IAAY,CAAE;QACzD,KAAK,CAAC,CAAC,OAAO,EAAE,UAAU,CAAC;aADX,YAAA;aAA2B,OAAA;IAE/C;IAEA,MAAM,UAAyB;QAC3B,MAAM,aAAa,CAAA,GAAA,uBAAe;QAClC,MAAM,WAAW,IAAI,+BAAS;QAC9B,MAAM,UAAU,IAAI,CAAA,GAAA,aAAK,EAAE;YACvB,SAAS,IAAI,CAAC,SAAS;YACvB,eAAe;YACf,MAAM;YACN,UAAU;QACd;QAEA,IAAI;YACA,IAAI,eAAE,WAAW,EAAE,GAAG,MAAM,QAAQ,GAAG;YAEvC,KAAK,IAAI,UAAU,YAAY,UAAU,GAAI;gBAC3C,QAAQ,GAAG,CAAC,OAAO,QAAQ;gBAC3B,QAAQ,GAAG,CAAC,MAAM,SAAS,QAAQ,CAAC,OAAO,QAAQ,EAAE;YACvD;QACJ,SAAU;YACN,MAAM,WAAW,GAAG;QACxB;IACJ;AACJ;;;;;AE5BO,MAAM,kDAAiB,CAAA,GAAA,yCAAG;;IAC7B,YAAY,AAAQ,SAAiB,CAAE;QACnC,KAAK,CAAC,CAAC,KAAK,EAAE,UAAU,CAAC;aADT,YAAA;IAEpB;IAEA,MAAM,UAA6B;QAC/B,IAAI;QAEJ,IAAI;YACA,QAAQ,MAAM,CAAA,GAAA,iBAAC,EAAE,OAAO,CAAC,IAAI,CAAC,SAAS;QAC3C,EAAE,OAAO,KAAK;YACV,MAAM,IAAI,MAAM,8BAA8B,IAAI,KAAK;QAC3D;QAEA,OAAO;IACX;AACJ;;;AJdO,MAAM;;;IACD,QAAiC;IACzC,YAAY,AAAQ,MAAc,EAAE,AAAQ,MAAc,CAAE;aAAxC,SAAA;aAAwB,SAAA;aADpC,UAAmB,IAAI,CAAA,GAAA,yCAAM;IAErC;IAEA,MAAM,SAAS;QACX,IAAI,YAAY,KAAK,GAAG;QAExB,MAAM,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAA,GAAA,yCAAS,EAAE,CAAA,GAAA,WAAG,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,SAAS;QAE1E,MAAM,WAAW,MAAM,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAA,GAAA,yCAAO,EAAE,CAAA,GAAA,WAAG,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;QAEhF,KAAK,MAAM,QAAQ,SACf,MAAM,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAA,GAAA,yCAAS,EAAE,CAAA,GAAA,WAAG,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,WAAW,OAAO,cAAc;QAGrG,QAAQ,GAAG,CAAC,KAAK,GAAG,KAAK;IAC7B;AACJ;;;;ADpBA,MAAM,iCAAW,IAAI,CAAA,GAAA,yCAAO,EAAE,CAAA,GAAA,kBAAM,EAAE,GAAG,IAAI,CAAA,GAAA,kBAAM,EAAE,GAAG,KAAK;AAE7D,+BAAS,MAAM","sources":["src/main.ts","src/packager.ts","src/manager.ts","src/task/bundle-task.ts","src/task.ts","src/task/list-task.ts"],"sourcesContent":["import { Packager } from \"./packager.js\";\nimport process from \"node:process\";\n\nconst packager = new Packager(process.cwd(), process.cwd() + \"/packager/dist\");\n\npackager.bundle();","import { Manager } from \"./manager.js\";\nimport path from \"path\";\nimport { BundleTask } from \"./task/bundle-task.js\";\nimport { ListTask } from \"./task/list-task.js\";\n\nexport class Packager {\n    private manager: Manager = new Manager();\n    constructor(private source: string, private target: string) {\n    }\n\n    async bundle() {\n        let startTime = Date.now();\n\n        await this.manager.execute(new BundleTask(path.join(this.source, \"main\"), \"@main\"));\n\n        const packages = await this.manager.execute(new ListTask(path.join(this.source, \"package\")));\n\n        for (const name of packages) {\n            await this.manager.execute(new BundleTask(path.join(this.source, \"package\", name), \"@package/\" + name));\n        }\n\n        console.log(Date.now() - startTime);\n    }\n}","import { Task } from \"./task.js\";\nimport process from \"node:process\";\n\nexport class Manager {\n    currentTask: Task<any> = null;\n\n    constructor() {\n        process.on('uncaughtException', (err) => {\n            this.currentTask?.onError(err);\n        });\n    \n        process.on('beforeExit', () => {\n            this.currentTask?.onExit();\n        });\n    }\n\n    execute<T>(task: Task<T>): Promise<T> {\n        if (this.currentTask) {\n            this.currentTask.onExpire();\n        }\n\n        this.currentTask = task;\n\n        return task._execute();\n    }\n\n    // list(directory: string) {\n    //     console.log(`List ${directory}`);\n    // }\n\n    // read(file: string) {\n    //     console.log(`Read ${file}`);\n    // }\n\n    // write(file: string) {\n    //     console.log(`Write ${file}`);\n    // }\n\n    // create(directory: string) {\n    //     console.log(`Create ${directory}`);\n    // }\n\n    // remove(file: string) {\n    //     console.log(`Remove ${file}`);\n    // }\n\n    // bundle(name: string) {\n    //     console.log(`Bundling ${name}`);\n    // }\n\n    // move(from: string, to: string) {\n    //     console.log(`Move ${from} to ${to}`);\n    // }\n\n    // copy(from: string, to: string) {\n    //     console.log(`Copy ${from} to ${to}`);\n    // }\n\n    // error(error: any) {\n    //     console.log(`Error: ${error.toString()}`);\n    // }\n\n    // success(time: number) {\n    //     console.log(`âœ¨ Packaged in ${time}ms`);\n    // }\n}","import { Task } from '../task.js';\nimport { Parcel, createWorkerFarm } from '@parcel/core';\nimport parcelFs from '@parcel/fs';\nconst { MemoryFS } = parcelFs;\n\nexport class BundleTask extends Task<void> {\n    constructor(private directory: string, private root: string) {\n        super(`Bundle ${directory}`);\n    }\n\n    async execute(): Promise<void> {\n        const workerFarm = createWorkerFarm();\n        const memoryFs = new MemoryFS(workerFarm);\n        const bundler = new Parcel({\n            entries: this.directory,\n            defaultConfig: '@parcel/config-default',\n            mode: 'production',\n            outputFS: memoryFs\n        });\n\n        try {\n            let { bundleGraph } = await bundler.run();\n\n            for (let bundle of bundleGraph.getBundles()) {\n              console.log(bundle.filePath);\n              console.log(await memoryFs.readFile(bundle.filePath, 'utf8'));\n            }\n        } finally {\n            await workerFarm.end();\n        }\n    }\n}","import chalk from \"chalk\";\nimport process from \"node:process\";\n\nexport abstract class Task<T> {\n    private complete: boolean;\n\n    constructor(protected message: string) {\n    }\n\n    public onError(error: Error) {\n        console.log(chalk.redBright(this.message));\n        console.log(chalk.red(error.stack));\n\n        process.exit(1);\n    }\n\n    public onExit() {\n        if (this.complete) return;\n\n        console.log(chalk.yellowBright(this.message));\n        console.log(chalk.yellow(\"Process exited before task was resolved\"));\n    }\n\n    public onExpire() {\n        if (this.complete) return;\n\n        console.log(chalk.yellowBright(this.message));\n        console.log(chalk.yellow(\"Another task began before this one completed\"));\n    }\n\n    private resolve() {\n        console.log(chalk.greenBright(this.message));\n\n        this.complete = true;\n    }\n\n    private reject(message: string) {\n        console.log(chalk.redBright(this.message));\n        console.log(chalk.red(message));\n\n        process.exit(1);\n    }\n\n    public _execute(): Promise<T> {\n        return new Promise(resolve => {\n            this.execute().then((result) => {\n                this.resolve();\n\n                resolve(result);\n            }).catch((error) => {\n                this.reject(error);\n            });\n        });\n    }\n\n    public abstract execute(): Promise<T>;\n}","import fs from 'fs/promises';\nimport { Task } from '../task.js';\n\nexport class ListTask extends Task<string[]> {\n    constructor(private directory: string) {\n        super(`List ${directory}`);\n    }\n\n    async execute(): Promise<string[]> {\n        let files: string[];\n\n        try {\n            files = await fs.readdir(this.directory);\n        } catch (err) {\n            throw new Error(\"Failed to read directory: \", err.stack);\n        }\n\n        return files;\n    }\n}"],"names":[],"version":3,"file":"main.js.map","sourceRoot":"../"}